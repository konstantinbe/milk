#!/usr/bin/env ruby

require 'fileutils'
require 'rubygems'
require 'net/github-upload'
require 'ERB'

# ------------------------------------------------------------- custom tasks ---

task :build => [:prepare, 'build:milk', 'build:specs', 'build:package']

task 'build:milk' => [:prepare] do
  put "Compiling Milk ... "
  run "commands/milk join source/milk"
  run "coffee --compile build/milk.coffee"
  run "cp resources/milk.html build/" unless File.exists? "build/milk.html"
  puts OK
end

task 'build:package' => [:prepare, 'build:milk'] do
  put "Preparing release package ... "
  delete_file_if_exists "build/#{NAME}-#{RELEASE}"
  run "mkdir build/#{NAME}-#{RELEASE}"
  run "cp build/#{NAME}.js build/#{NAME}-#{RELEASE}/"
  puts OK
end

task 'build:specs' => [:prepare] do
  put "Compiling specs ... "
  run "coffee --join --compile --output build/ resources/spec-helper.coffee specs/*.coffee"
  run "mv build/concatenation.js build/specs.js"
  run "cp -r externals/jasmine/lib build/jasmine" unless File.exists? "build/jasmine"
  run "cp resources/specs.html build/" unless File.exists? "build/specs.html"
  puts OK
end

task :specs => ['specs:node'] do

end

task 'specs:browser' => [:prepare, 'build:milk', 'build:specs'] do
  put "Opening specs in browser ... "
  run "open build/specs.html"
  puts OK
end

task 'specs:node' => [:prepare, 'build:milk', 'build:specs'] do
  put "Preparing specs ... "
  run "cp resources/run-specs-on-node.js build/"
  puts OK
  run "cd build/;node run-specs-on-node.js"
end

task :serve => [:build] do
  host = `hostname`.chop
  puts ""
  puts "Open in browser:"
  puts "    * http://#{host}:3001/milk"
  puts "    * http://#{host}:3001/specs"
  puts ""

  server = """
    require 'rubygems'
    require 'sinatra'
    set :server, %w[webrick]
    set :port, 3001
    set :static, true
    set :root, 'build/'
    set :public, 'build/'

    get '/' do
      redirect '/specs'
    end

    get '/milk', :provides => 'html' do
      File.open('build/milk.html', 'r') { |file| file.read }
    end

    get '/specs', :provides => 'html' do
      File.open('build/specs.html', 'r') { |file| file.read }
    end
  """
  run "ruby -e \"#{server}\""
end

# ------------------------------------------------------------ default tasks ---

task :release => [:check, :clean, :prepare, :build, :pack, :upload, :update, :tag, :push] do
  puts "Released version #{RELEASE}."
end

task :check do
  put "Checking whether the Changelog has an entry marked with 'Underway' ... "
  readme = File.open("README.md", "r") { |file| file.read }
  check readme.match /^### (\d\.\d.+) - Underway/
  puts OK

  put "Checking whether version #{RELEASE} isn't already released ... "
  output = `git tag`
  check (not (output.match RELEASE))
  puts OK

  put "Checking whether repo is clean ... "
  output = `git status`
  check output.match "working directory clean"
  puts OK

  put "Checking whether on branch master ... "
  output = `git status`
  check output.match "On branch master"
  puts OK

  put "Checking whether master in sync with origin/master ... "
  output = `git diff master origin/master`
  check output.length == 0
  puts OK
end

task :clean do
  put "Cleaning ... "
  delete_file_if_exists "build"
  puts OK
end

task :prepare do
  run "mkdir build" unless File.exists? "build"
end

task :pack do
  put "Packing release package ... "
  run "cd build; zip -rq #{NAME}-#{RELEASE}.zip #{NAME}-#{RELEASE}; cd .."
  puts OK
end

task :upload do
  put "Uploading release package to GitHub ... "
  repos = REPO.scan(/git@github\.com:(.*)\.git/).to_s

  github = Net::GitHub::Upload.new :login => LOGIN, :token => TOKEN
  direct_link = github.upload :repos => repos, :file  => "build/#{NAME}-#{RELEASE}.zip", :description => ""
  puts OK
end

task :update do
  put "Updating Changelog in README ... "
  readme = File.open("README.md", "r") { |file| file.read }
  readme.gsub! /^### (\d\.\d.+) - Underway/, '### \1'
  File.open("README.md", "w") { |file| file.write readme }
  output = `git add README.md`
  output = `git commit -m 'Released #{RELEASE}.'`
  puts OK
end

task :tag do
  put "Tagging ... "
  output = `git tag #{RELEASE}`
  puts OK
end

task :push do
  put "Pushing changes ... "
  output = `git push`
  puts OK

  put "Pushing tags ... "
  output = `git push --tags`
  puts OK
end

task :init do
  put "Setting up repo ... "
  run "mv .git/hooks/pre-commit.sample .git/hooks/pre-commit" unless File.exists? ".git/hooks/pre-commit"
  run "git config --unset core.ignorecase" if `git config core.ignorecase`.length > 0
  puts OK

  put "Initializing submodules ... "
  run "git submodule init"
  run "git submodule update"
  puts OK

  put "Setting up wiki ... "
  run "git clone #{WIKI} wiki" unless File.exists? "wiki"
  run "mv wiki/.git/hooks/pre-commit.sample wiki/.git/hooks/pre-commit" unless File.exists? "wiki/.git/hooks/pre-commit"
  run "cd wiki; git config --unset core.ignorecase" if `git config core.ignorecase`.length > 0
  puts OK
end

task :info do
  puts "Repository URL:         " + REPO
  puts "Repository Name:        " + NAME
  puts "Wiki Repository URL:    " + WIKI
  puts "GitHub User:            " + LOGIN
  puts "GitHub Token:           " + TOKEN
end

# ---------------------------------------------------------------- functions ---

def assert(condition, message = "")
  unless condition
    puts message + "\n\n"
    exit 1
  end
end

def check(condition)
  unless condition
    puts FAILED
    exit 1
  end
end

def run(command)
  success = system command
  check success
end

def delete_file_if_exists(path)
  run "rm -rf #{path}" if File.exists? path
end

def put(string)
  print string
  STDOUT.flush
end

def render_erb_template_to_file(template_path, binding, file_path)
  template = File.open(template_path, "r") { |file| ERB.new(file.read) }
  cache_xml = template.result binding
  File.open(file_path, "w") { |file| file.write(cache_xml) }
end

# ---------------------------------------------------------------- constants ---

REPO = `git config remote.origin.url`.chomp
NAME = REPO.scan(/\/(.*)\.git/).first.first.to_s
WIKI = REPO.gsub ".git", ".wiki.git"
LOGIN = `git config github.user`.chomp
TOKEN = `git config github.token`.chomp
OK = "\33[0m\33[32mOK\33[0m"
FAILED = "\33[0m\33[31mFAILED\33[0m"
RELEASE = File.open("README.md", "r") { |file| file.read }.scan(/^### (\d(?:\.\d+)+)\s/).first.first.to_s
